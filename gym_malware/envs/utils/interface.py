import requests
import gzip
import json
import re

import sys
import os
import glob
import pefile

module_path = os.path.dirname(os.path.abspath(sys.modules[__name__].__file__))

SAMPLE_PATH = os.path.join(module_path, 'samples')

MALWARE_LABEL = 1.0
BENIGN_LABEL = 0.0

from gym_malware.envs.utils.models import *
#MALCONV_MODEL_PATH = os.path.join(module_path, "malconv/malconv.checkpoint")
#EMBER_2019_MODEL_PATH = os.path.join(module_path, 'ember_2019/ember_model.txt')


# for local model
#import joblib

#local_model = joblib.load(os.path.join(module_path, 'gradient_boosting.pkl'))
#local_model = joblib.load(os.path.join(module_path, 'lgbm_ember'))

#local_model_threshold = 0.90
#local_model_threshold = 0.8336 # 1% FPR
#local_model_threshold = 0.9996 # 0.1% FPR

class ClassificationFailure(Exception):
    pass


class FileRetrievalFailure(Exception):
    pass

def load_PE(path):    
    pe_file = pefile.PE(name=path)
    return pe_file

# TODO edit
def fetch_file(sha256):
    location = os.path.join(SAMPLE_PATH, "all", sha256)
#    try:
    with open(location, 'rb') as infile:
        bytez = infile.read()
#    except IOError:
#        raise FileRetrievalFailure(
#            "Unable to read sha256 from {}".format(location))

    return bytez

def read_bytes(path):
    #try:
    with open(path, 'rb') as infile:
        bytez = infile.read()
    #except IOError:
    #    raise FileRetrievalFailure(
    #        "Unable to read bytes from {}".format(path))

    return bytez

def get_sha256(path):
    sha256list = []
    for fp in glob.glob(os.path.join(path, '*')):
        fn = os.path.split(fp)[-1]
        result = re.match(".*", fn) # match anything re.match(r'^[0-9a-fA-F]{64}$', fn) # require filenames to be sha256
        #result = fn # TODO load any file
        if result:
            sha256list.append(result.group(0))
    assert len(sha256list)>0, "no files found in {} with sha256 names".format( path )

    return sha256list

def get_size(path):
    return os.path.getsize(path)
    #return load_PE(path).OPTIONAL_HEADER.SizeOfImage

def get_size_sha256(sha256):
    location = os.path.join(SAMPLE_PATH, "all", sha256)
    return get_size(location)

def get_available_sha256():
    sha256list = get_sha256(os.path.join(SAMPLE_PATH, "all"))

    return sha256list
    
def get_train_test_sha256():
    train = get_sha256(os.path.join(SAMPLE_PATH, "train"))
    test = get_sha256(os.path.join(SAMPLE_PATH, "test"))      
    
    all_files = get_sha256(os.path.join(SAMPLE_PATH, "all"))

    num_train = len(train)
    num_test = len(test)

    if (num_train + num_test) > len(all_files):
        os.system(f"cp {os.path.join(SAMPLE_PATH, 'train', '*')} {os.path.join(SAMPLE_PATH, 'all')}")
        return get_train_test_sha256()

    assert (num_train + num_test) <= len(all_files), "missing files in samples/all directory"

    print(f"Number of train/test files: {len(train)}/{len(test)}")
    return train, test
    
def remove_files(folder):
    for f in glob.glob(os.path.join(folder, "*")):
        try:
            os.remove(f)
        except Exception as e:
            print("Failed to remove file: ", e)

def remove_file(file_path):
    if os.path.exists(file_path):
        try:
            os.remove(glob.glob(file_path)[0])
        except Exception as e:
            print(file_path)
            print("failed to remove file:", e)
    else:
        print("The file does not exist")

# Testing for mixture setup
def true_label(file_path):
    return MALWARE_LABEL
    
    r = re.compile("malware")

    if r.match(file_path) == None:
        return BENIGN_LABEL
    else:
        return MALWARE_LABEL



#TARGET_MODEL = EmberModel_2019(EMBER_2019_MODEL_PATH)
#TARGET_MODEL = MalConvModel(MALCONV_MODEL_PATH)

#def get_score_local(bytez):
#    return TARGET_MODEL.get_score(bytez)

# mimic black box by thresholding here
#def get_label_local(bytez):
#    score = get_score_local(bytez)
#    label = float(score >= TARGET_MODEL.thresh)
    #print("score={} (hidden), label={}".format(score,label)) 
#    return label
