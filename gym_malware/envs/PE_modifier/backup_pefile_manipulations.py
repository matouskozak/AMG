### Source code from https://github.com/weisong-ucr/MAB-malware ###
### https://axcheron.github.io/code-injection-with-python/ ###

import pefile
import os
import pickle
import sys
import multiprocessing
import signal
import array
import random
import mmap
import tempfile
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s %(name)s - %(levelname)s - %(message)s',
    datefmt='%d-%b-%y %H:%M:%S',
    handlers = [
        #logging.FileHandler(filename = "pe_manip.log"),
        logging.StreamHandler(sys.stdout)
    ]
)

    #filename='example.log', filemode='w', ,)

logger = logging.getLogger("PE_manip_logger")
logger.info(f"Logger {logger.name} started...")

# TODO Change
module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]
### https://github.com/CyberForce/Pesidious ### 
COMMON_SECTION_NAMES = pickle.load(open(os.path.join(module_path, 'RL_Features/adversarial_sections_set.pk'), "rb"))
COMMON_IMPORTS = pickle.load(open(os.path.join(module_path, 'RL_Features/adversarial_imports_set.pk'), "rb"))
#section_content = "gym_malware/envs/controls/section-content.txt"
section_content = os.path.join(module_path, "section-content.txt")
imported_libs = os.path.join(module_path, "imports.txt")
append_import_script = os.path.join(module_path, "project-append-import") # script from Pesidious

    

class PefileManipulator(object):
    def __init__(self, input_path, output_folder):
        logger.info(f"Initialized PefileManipulator with input: {input_path} and output: {output_folder}")
        self.input_path = input_path
        self.output_folder = output_folder
        self.output_path = PefileManipulator.get_output_path(output_folder, input_path)
        
        
    @staticmethod
    def get_benign_content(size):
        with open(section_content, 'r') as infile:
            sec_content = infile.read()
        
        return "\n ".join(random.sample(sec_content.split("\n"), size))
        
    @staticmethod
    def get_output_path(folder, input_path):
        #return os.path.join(folder, os.path.basename(input_path))
        return os.path.join(folder, next(tempfile._get_candidate_names()))
    
    @staticmethod        
    def load_PE(path):
        logger.debug(f"Loading file: {path}")
        
        try:
            pe_file = pefile.PE(name=path)
            return pe_file
        except OSError as e:
            logger.exception(e)
        except pefile.PEFormatError as e:
            logger.exception("[-] PEFormatError: %s" % e.value)
            
        return None

    @staticmethod
    def get_overlay_size(path):
        file_size = os.path.getsize(path)
        pe = PefileManipulator.load_PE(path)

        if pe == None:
            return 0
            
        overlay_offset = pe.get_overlay_data_start_offset()
        overlay_size = 0
        if overlay_offset != None:
            overlay_size = file_size - overlay_offset
            
        return overlay_size
     
    @staticmethod   
    def align(val_to_align, alignment):
        return int((val_to_align + alignment - 1) / alignment) * alignment
        
    @staticmethod
    def get_random_section_name(seed = None):
        name = 8 * ['\00']
        random_name = random.choice(COMMON_SECTION_NAMES)[:7]
        
        for i in range(len(random_name)):
            name[i] = random_name[i]
            
        return name
            
    
    
    # Remove DEBUG directory from PE file if present
    def remove_debug(self):
        pe = PefileManipulator.load_PE(self.input_path)
        segment_size = 0
        for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            if d.name == 'IMAGE_DIRECTORY_ENTRY_DEBUG':
                if d.Size > 0: # non-empty debug
                    debug_directories = pe.parse_debug_directory(d.VirtualAddress, d.Size)
                    if debug_directories:
                        for debug_directory in debug_directories:
                            debug_type = debug_directory.struct.Type
                            if debug_type == 2: # Zero out directory
                                file_offset = debug_directory.struct.PointerToRawData
                                segment_size = debug_directory.struct.SizeOfData
                                pe.set_bytes_at_offset(file_offset, (segment_size * '\x00').encode())

                    d.VirtualAddress = 0
                    d.Size = 0

        
        pe.write(self.output_path)
        
        return self.output_path
        

    # TODO improve 90/100    
    # Remove CERTIFICATE (SECURITY) directory from PE file if present
    def remove_certificate(self):
        pe = PefileManipulator.load_PE(self.input_path)
        for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            if d.name == 'IMAGE_DIRECTORY_ENTRY_SECURITY':
                if d.VirtualAddress > 0: # non-empty certificate
                    size_in_sig = pe.get_word_from_offset(d.VirtualAddress)
                    if size_in_sig == d.Size:
                        pe.set_bytes_at_offset(d.VirtualAddress, ('\x00'*(d.Size)).encode())
                        d.VirtualAddress = 0
                        d.Size = 0

        pe.write(self.output_path)
        
        return self.output_path

    # Zero out OPTIONAL_HEADER CheckSum
    def break_checksum(self):       
        pe = PefileManipulator.load_PE(self.input_path)

        pe.OPTIONAL_HEADER.CheckSum = 0
        pe.write(self.output_path)
        
        return self.output_path
        
    # Choose random section and rename it to random common section name
    def rename_section(self):       
        pe = PefileManipulator.load_PE(self.input_path)

        if len(pe.sections) == 0:
            os.system(f"cp -p {self.input_path} {self.output_path}")
            return self.output_path
            
        targeted_section = random.choice(pe.sections)
        name = PefileManipulator.get_random_section_name()
        
        targeted_section.Name = "".join(name).encode()
        
        pe.write(self.output_path)
        
        return self.output_path
        

    # TODO Improve 76/100
        
    # Add new section to PE file if enough space for header
    # with benign content
    def add_section(self):        
        pe = PefileManipulator.load_PE(self.input_path)   
        
        number_of_section = pe.FILE_HEADER.NumberOfSections
        last_section = number_of_section - 1
        file_alignment = pe.OPTIONAL_HEADER.FileAlignment
        section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
        ENTRY_SIZE = 40
        
        # File without sections
        # weird, but don't know how to handle this yet
        #if last_section < 0:
         #   os.system(f"cp -p {self.input_path} {self.output_path}")
          #  return self.output_path
          
          
        if last_section >= len(pe.sections):
            os.system(f"cp -p {self.input_path} {self.output_path}")
            return self.output_path
            
        new_section_offset = pe.sections[last_section].get_file_offset() + ENTRY_SIZE
            
        first_section_offset = pe.sections[0].PointerToRawData
        next_header_space_size = first_section_offset - new_section_offset
        
        # Not enough space for new section header
        if next_header_space_size < ENTRY_SIZE:
            os.system(f"cp -p {self.input_path} {self.output_path}")
            return self.output_path

        content = PefileManipulator.get_benign_content(random.randint(1, 100)).encode()
        
        # Look for valid values for the new section header
        raw_size = self.align(len(content), file_alignment)
        virtual_size = self.align(len(content), section_alignment)
        raw_offset = self.align((pe.sections[last_section].PointerToRawData +
                        pe.sections[last_section].SizeOfRawData),
                       file_alignment)

        virtual_offset = self.align((pe.sections[last_section].VirtualAddress +
                            pe.sections[last_section].Misc_VirtualSize),
                           section_alignment)

        original_size = os.path.getsize(self.input_path)
        fd = open(self.input_path, 'a+b')
        map = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_WRITE)
        map.resize(original_size + raw_size)
        map.close()
        fd.close()

        name = PefileManipulator.get_random_section_name()

        # CODE | EXECUTE | READ | WRITE
        characteristics = 0xE0000020
       
        # Create the SEACTION HEADER
        # Set the name
        pe.set_bytes_at_offset(new_section_offset, "".join(name).encode())
        #print("\t[+] Section Name = %s" % "".join(name).encode())
        # Set the virtual size
        pe.set_dword_at_offset(new_section_offset + 8, virtual_size)
        #print("\t[+] Virtual Size = %s" % hex(virtual_size))
        # Set the virtual offset
        pe.set_dword_at_offset(new_section_offset + 12, virtual_offset)
        #print("\t[+] Virtual Offset = %s" % hex(virtual_offset))
        # Set the raw size
        pe.set_dword_at_offset(new_section_offset + 16, raw_size)
        #print("\t[+] Raw Size = %s" % hex(raw_size))
        # Set the raw offset
        pe.set_dword_at_offset(new_section_offset + 20, raw_offset)
        #print("\t[+] Raw Offset = %s" % hex(raw_offset))
        # Set the following fields to zero
        pe.set_bytes_at_offset(new_section_offset + 24, (12 * '\x00').encode())
        # Set the characteristics
        pe.set_dword_at_offset(new_section_offset + 36, characteristics)
        #print("\t[+] Characteristics = %s\n" % hex(characteristics))

        # STEP 0x03 - Modify the Main Headers
        pe.FILE_HEADER.NumberOfSections += 1
        pe.OPTIONAL_HEADER.SizeOfImage = virtual_size + virtual_offset


        pe.set_bytes_at_offset(raw_offset, content)
        
        pe.write(self.output_path)
        
        return self.output_path
        
    def overlay_append(self):
        with open(self.input_path, 'rb') as infile:
            bytez = infile.read()
        
        bytez = bytez + PefileManipulator.get_benign_content(random.randint(1, 100)).encode()
    
        with open(self.output_path, 'wb') as outfile:
            outfile.write(bytez)
        
        return self.output_path
        

    # TODO Improve 45/100
        
    # Shuffles section header on byte level, doesn't show in pefile
    # TODO keep section alignment
    def shuffle_sections(self):
        pe = PefileManipulator.load_PE(self.input_path)   
        
        
        OFFSET_OPTIONAL_HEADER = pe.OPTIONAL_HEADER.get_file_offset()
        SIZE_OPTIONAL_HEADER = pe.FILE_HEADER.SizeOfOptionalHeader
        NUM_SECTIONS = pe.FILE_HEADER.NumberOfSections
        OFFSET_SECTION_TABLE = OFFSET_OPTIONAL_HEADER + SIZE_OPTIONAL_HEADER
        ENTRY_SIZE = 40
        SECTION_HEADERS = [None] * NUM_SECTIONS
        
        
        bytez = pe.get_bytes_from_data(OFFSET_SECTION_TABLE, pe.get_data())
        
        # Extract individual section headers
        current_offset = 0
        for i in range(NUM_SECTIONS):
            SECTION_HEADERS[i] = bytez[current_offset:current_offset + ENTRY_SIZE]    
            current_offset += ENTRY_SIZE
    
        # shuffle
        random.shuffle(SECTION_HEADERS)
        reordered_section_table = b''.join(SECTION_HEADERS)

        # copy original file
        os.system(f"cp -p {self.input_path} {self.output_path}")
        
        # rewrite section table
        fh = open(self.output_path, "r+b")
        fh.seek(OFFSET_SECTION_TABLE)
        fh.write(reordered_section_table)
        fh.close()
        
        return self.output_path

        
    def increase_timedatestamp(self):
        pe = PefileManipulator.load_PE(self.input_path) 
        
        pe.FILE_HEADER.TimeDateStamp = pe.FILE_HEADER.TimeDateStamp + 43200000  
        
        pe.write(self.output_path)
        
        return self.output_path
        
    def decrease_timedatestamp(self):
        pe = PefileManipulator.load_PE(self.input_path) 
        
        pe.FILE_HEADER.TimeDateStamp = max(0, pe.FILE_HEADER.TimeDateStamp - 43200000)
        
        pe.write(self.output_path)
        
        return self.output_path
    
    # TODO IMPROVE 39/100

    #rework with pefile
    def append_imports(self):       
        #pe = PefileManipulator.load_PE(self.input_path)    
        #e_lfanew = pe.DOS_HEADER.e_lfanew
        
        with open(self.input_path, 'rb') as infile:
            bytez = infile.read()      
            
        #old_DOS = bytez[:e_lfanew]     
               
        importsFile = open(imported_libs , 'w') # Creates new file
        
        libname = random.choice(list(COMMON_IMPORTS))

        #while(len(list(COMMON_IMPORTS[libname])) < 20 ):
        #    libname = random.choice(list(COMMON_IMPORTS))

        # Save imported functions and lib name to it 
        importsFile.write(libname + '\n')
        for fun in (list(COMMON_IMPORTS[libname])):
            importsFile.write(fun + '\n')

        importsFile.close()

        tmp_path = self.output_path #self.get_output_path(tempfile._get_default_tempdir(), self.input_path)
        
        
        with open(tmp_path, 'wb') as file1:
            file1.write(bytez)

        cmd = f"{append_import_script} {tmp_path} {imported_libs} {self.output_path}"
        os.system(cmd)

        #with open(tmp_path, "rb") as binfile:
        #    bytez = binfile.read()
            
        #correct_file = old_DOS + bytez[16:]
        
        #with open(self.output_path, 'wb') as res_file:
        #    res_file.write(correct_file)
            

        return self.output_path
          
    def identity(self):
        os.system(f"cp -p {self.input_path} {self.output_path}")
        
        return self.output_path
        

    def section_append(self):
        pe = PefileManipulator.load_PE(self.input_path)
        pass
        return 
        
        


ACTION_TABLE = {
    'rename_section': 'rename_section',
    'add_section': 'add_section',
    'remove_certificate': 'remove_certificate',
    'remove_debug': 'remove_debug',
    'break_checksum': 'break_checksum',
    'overlay_append': 'overlay_append',
    #'shuffle_sections': 'shuffle_sections',
    'increase_timedatestamp': 'increase_timedatestamp',
    'decrease_timedatestamp': 'decrease_timedatestamp',
    'append_imports': 'append_imports',
    #'identity': 'identity'
}

# TODO save files to random name in tmp folder
def modify_PE_file(input_path, output_folder = tempfile._get_default_tempdir(), actions=[]):
    current_path = input_path
    output_path = PefileManipulator.get_output_path(output_folder, input_path)   
    

    for action in actions:
        if action == None:
            os.system(f"cp -p {current_path} {output_path}")
            current_path = output_path
            continue
            
        _action = ACTION_TABLE[action]

        try:
            current_path = PefileManipulator(current_path, output_folder).__getattribute__(_action)()
        except Exception as e:
            logger.exception(f"Error during manipulation action: {action}, {e}")            
            os.system(f"cp -p {current_path} {output_path}")    
            current_path = output_path

    
    return current_path
