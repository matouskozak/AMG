### Source code from https://github.com/weisong-ucr/MAB-malware ###
### https://axcheron.github.io/code-injection-with-python/ ###

import pefile
import os
import pickle
import sys
import multiprocessing
import signal
import array
import random
import mmap
import tempfile
import logging
import numpy as np
import struct

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s %(name)s - %(levelname)s - %(message)s',
    datefmt='%d-%b-%y %H:%M:%S',
    handlers = [
        #logging.FileHandler(filename="pe_manip.log"),
        logging.StreamHandler(sys.stdout)
    ]
)

    #filename='example.log', filemode='w', ,)

logger = logging.getLogger("PE_manip_logger")
logger.info(f"Logger {logger.name} started...")
logger.setLevel(logging.WARNING)

# TODO Change

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]
### https://github.com/CyberForce/Pesidious ### 
#COMMON_SECTION_NAMES = pickle.load(open(os.path.join(module_path, 'RL_Features/adversarial_sections_set.pk'), "rb"))
COMMON_IMPORTS = pickle.load(open(os.path.join(module_path, 'RL_Features/adversarial_imports_set.pk'), "rb"))
#section_content = "gym_malware/envs/controls/section-content.txt"
section_content = os.path.join(module_path, "section-content.txt")
imported_libs = os.path.join(module_path, "imports.txt")
append_import_script = os.path.join(module_path, "project-append-import") # script from Pesidious

def load_section_names():
    path = os.path.join(module_path, 'section_names.npz')
    with np.load(path) as data:
        return data['x'], data['y']
    

COMMON_SECTION_NAMES, COMMON_SECTION_NAMES_WEIGHTS = load_section_names()




class PefileManipulator(object):
    def __init__(self, input_path, output_folder, verbose=True, random_name=True):
        logger.info(f"Initialized PefileManipulator with input: {input_path} and output: {output_folder}")
        self.input_path = input_path
        self.output_folder = output_folder
        self.output_path = PefileManipulator.get_output_path(output_folder, input_path, random_name)
        self.verbose = verbose
        
    @staticmethod
    def get_output_path(folder, input_path, random_name):
        if random_name:
            return os.path.join(folder, next(tempfile._get_candidate_names()))
#            return os.path.join(folder, os.path.join(tempfile.mkdtemp(), os.path.basename(input_path)))
        else:
            return os.path.join(folder, os.path.basename(input_path))
    
    @staticmethod        
    def load_PE(path):
        logger.debug(f"Loading file: {path}")
        
        #try:
        pe_file = pefile.PE(name=path)
        return pe_file
        #except OSError as e:
        #    logger.exception("ERROR loading PE file" + e)
        #except pefile.PEFormatError as e:
        #    logger.exception("[-] PEFormatError: %s" % e.value)
            
        #return None

    # Get available space size after given section (section_idx)
    @staticmethod
    def get_available_space_size(pe, section_idx):
        num_sections = len(pe.sections)

        if section_idx >= num_sections:
            return 0

        section = pe.sections[section_idx]
        available_space_size = 0

        # Last section
        if section_idx == num_sections - 1: 
            overlay_offset = pe.get_overlay_data_start_offset()

            if overlay_offset == None:
                available_space_size = section.SizeOfRawData - section.Misc_VirtualSize 
            else:
                available_space_size = overlay_offset - section.PointerToRawData - section.Misc_VirtualSize
        else:
            available_space_size = pe.sections[section_idx + 1].PointerToRawData - section.PointerToRawData - section.Misc_VirtualSize

        return available_space_size

     
    @staticmethod   
    def align(val_to_align, alignment):
        return int((val_to_align + alignment - 1) / alignment) * alignment
        

    @staticmethod
    def get_benign_content(size, seed=None):
        with open(section_content, 'r') as infile:
            sec_content = infile.read()
        
        return "\n".join(random.sample(sec_content.split("\n"), size))
       
    @staticmethod
    def get_benign_section_characteristics(seed=None):
        vals = [0x60000020, 0x40000040, 0x42000040, 0xc0000040, 
                0xc0000080, 0xc0000000, 0x50000040, 0x0]
        weights = [100, 172, 70, 60, 1, 2, 3, 1]
        return random.choices(vals, weights)[0]

    @staticmethod
    def get_random_section_name(seed=None):
        name = 8 * ['\00']
        random_name = random.choices(COMMON_SECTION_NAMES, COMMON_SECTION_NAMES_WEIGHTS)
        
        for i in range(len(random_name)):
            name[i] = random_name[i]
            
        return name

    @staticmethod
    def all_zeros(byte_arr):
        for b in byte_arr:
            if b != 0:
                return False
            
        return True
                


    # 100/100 ok
    # Remove DEBUG directory from PE file if present
    def remove_debug(self):
        if self.verbose:
            logger.info("ACTION - REMOVE DEBUG")
            
        pe = PefileManipulator.load_PE(self.input_path)
        #segment_size = 0
        for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            if d.name == 'IMAGE_DIRECTORY_ENTRY_DEBUG':
                if d.Size > 0: # non-empty debug
                    debug_directories = pe.parse_debug_directory(d.VirtualAddress, d.Size)
                    if debug_directories:
                        # Clear individual debug directory entries content
                        for debug_directory in debug_directories:
                            #debug_type = debug_directory.struct.Type
                            #if debug_type == 2: # Zero out directory
                            file_offset = debug_directory.struct.PointerToRawData
                            segment_size = debug_directory.struct.SizeOfData
                            pe.set_bytes_at_offset(file_offset, (segment_size * '\x00').encode())

                    # Clear debug data directory from optional header
                    d.VirtualAddress = 0
                    d.Size = 0

        
        pe.write(self.output_path)
        
        return self.output_path
        

    ##### CHECK VALIDITY #####
    # TODO improve 90/100    
    # Remove CERTIFICATE (SECURITY) directory from PE file if present
    def remove_certificate(self):
        if self.verbose:
            logger.info("ACTION - REMOVE CERTIFIACTE")

        pe = PefileManipulator.load_PE(self.input_path)
        for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            if d.name == 'IMAGE_DIRECTORY_ENTRY_SECURITY':
                if d.Size > 0: # non-empty certificate                        
                    # Clear certificates content
                    pe.set_bytes_at_offset(d.VirtualAddress, (d.Size * '\x00').encode())
                    # TODO try zero only dwLength of certificate
                    #pe.set_bytes_at_offset(d.VirtualAddress, (4 * '\x00').encode())
                    
                    #current_offset = d.VirtualAddress # File pointer (raw offset)
                    #while (current_offset - d.VirtualAddress) < d.Size:
                    #    certificate_size = pe.get_word_from_offset(current_offset)
                    #    pe.set_bytes_at_offset(current_offset, ('\x00'*(certificate_size)).encode())
                    #    current_offset = PefileManipulator.align(current_offset + certificate_size, 8)


                    # Clear security data directory from optional header
                    d.VirtualAddress = 0
                    d.Size = 0

        pe.write(self.output_path)
        
        return self.output_path

    # 100/100 ok
    # Zero out OPTIONAL_HEADER CheckSum
    def break_checksum(self):  
        if self.verbose:
            logger.info("ACTION - BREAK CHECKSUM")
     
        pe = PefileManipulator.load_PE(self.input_path)

        pe.OPTIONAL_HEADER.CheckSum = 0
        pe.write(self.output_path)
        
        return self.output_path
        
    # 100/100 ok
    # Choose random section and rename it to random common section name
    def rename_section(self): 
        if self.verbose:      
            logger.info("ACTION - RENAME SECTION")

        pe = PefileManipulator.load_PE(self.input_path)

        # If no sections in the PE file
        if len(pe.sections) == 0:
            if self.verbose:
                logger.info("No sections present in a PE file.")
            os.system(f"cp -p {self.input_path} {self.output_path}")
            return self.output_path
            
        # Choose section and its new name
        targeted_section = random.choice(pe.sections)
        name = PefileManipulator.get_random_section_name()
        
        # Rename section
        targeted_section.Name = "".join(name).encode()
        
        pe.write(self.output_path)
        
        return self.output_path
        

    # TODO try reuse overlay content as a new section content
    # TODO Improve 98/100
    # Add new section to PE file if enough space for header
    # with benign content
    def add_section(self):   
        if self.verbose:     
            logger.info("ACTION - ADD SECTION")

        pe = PefileManipulator.load_PE(self.input_path)   
        
        #number_of_section = pe.FILE_HEADER.NumberOfSections
        number_of_section = len(pe.sections)
        #last_section = number_of_section - 1
        file_alignment = pe.OPTIONAL_HEADER.FileAlignment
        section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
        ENTRY_SIZE = 40
        original_size = os.path.getsize(self.input_path)
        
        # File without sections
        # weird, but don't know how to handle this yet
        #if last_section < 0:
         #   os.system(f"cp -p {self.input_path} {self.output_path}")
          #  return self.output_path
          
          
        # TODO What is this?!
        #if last_section >= len(pe.sections): # TODO move to number_of_section adn delete
        #    os.system(f"cp -p {self.input_path} {self.output_path}")
        #    return self.output_path
            
        new_section_offset = pe.sections[-1].get_file_offset() + ENTRY_SIZE # End of the last section header
        
        # TODO change to pe.OPTIONAL_HEADER.SizeOfHeaders
        first_section_offset = pe.sections[0].PointerToRawData # Start of first section content
        #first_section_offset = pe.OPTIONAL_HEADER.SizeOfHeaders

        next_header_space_size = first_section_offset - new_section_offset # Difference between start of first section and end of last section header
        
        # Not enough space for new section header
        if next_header_space_size < ENTRY_SIZE:
            if self.verbose:
                logger.info("Cannot add new section, not enough space for new section header.")
            os.system(f"cp -p {self.input_path} {self.output_path}")
            return self.output_path

        # Prepare content
        content = PefileManipulator.get_benign_content(random.randint(1, 100)).encode()
        #content = (1*'\x00').encode()
        
        # Look for valid values for the new section header
        raw_size = self.align(len(content), file_alignment) # align raw content size with FileAlignment (on disk)
        virtual_size = self.align(len(content), section_alignment) # align raw content size with SectionAlignment (in memory)
        raw_offset = self.align((pe.sections[-1].PointerToRawData +
                        pe.sections[-1].SizeOfRawData),
                       file_alignment) # Offset of the new section's beginning (on disk)
        virtual_offset = self.align((pe.sections[-1].VirtualAddress +
                            pe.sections[-1].Misc_VirtualSize),
                           section_alignment) # Offset of the new section's beginning (in memory)


        # Make space for new section content
        os.system(f"cp -p {self.input_path} {self.output_path}")
        fd = open(self.output_path, 'a+b')
        map = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_WRITE)
        map.resize(original_size + raw_size)
        map.close()
        fd.close()


        # Reload modified file
        pe = PefileManipulator.load_PE(self.output_path)   
        # Get name for the new section
        name = PefileManipulator.get_random_section_name()


        # Most common benign characteristics at weighted random
        characteristics = PefileManipulator.get_benign_section_characteristics()
       
        # Create the SEACTION HEADER
        # Set the Name
        pe.set_bytes_at_offset(new_section_offset, "".join(name).encode())
        # Set the VirtualSize
        pe.set_dword_at_offset(new_section_offset + 8, virtual_size)
        # Set the VirtualAddress
        pe.set_dword_at_offset(new_section_offset + 12, virtual_offset)
        # Set the SizeOfRawData
        pe.set_dword_at_offset(new_section_offset + 16, raw_size)
        # Set the PointerToRawData
        pe.set_dword_at_offset(new_section_offset + 20, raw_offset)
        # Set the following fields to zero, not used in PE executable
        pe.set_bytes_at_offset(new_section_offset + 24, (12 * '\x00').encode())
        # Set the Characteristics
        pe.set_dword_at_offset(new_section_offset + 36, characteristics)

        # Modify the main headers
        pe.FILE_HEADER.NumberOfSections += 1
        pe.OPTIONAL_HEADER.SizeOfImage = virtual_size + virtual_offset
        #pe.OPTIONAL_HEADER.SizeOfHeaders = self.align(pe.OPTIONAL_HEADER.SizeOfHeaders + ENTRY_SIZE, file_alignment)


        # TODO try to copy overlay data into section content to prevent problems
        # Overlay data
        old_overlay_offset = pe.get_overlay_data_start_offset()
        new_overlay_offset = raw_offset + raw_size
        overlay_content = pe.get_overlay()

        # Write main section content
        pe.set_bytes_at_offset(raw_offset, content)
        
        # Move overlay further
        pe.set_bytes_at_offset(new_overlay_offset, bytes(overlay_content))

        # Redirect certificates
        for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            if d.name == 'IMAGE_DIRECTORY_ENTRY_SECURITY':
                if d.Size > 0:
                    d.VirtualAddress += new_overlay_offset - old_overlay_offset       


        pe.write(self.output_path)
        
        return self.output_path




            

    # 100/100 ok
    # Add random benign content to file overlay
    def overlay_append(self):
        logger.info("ACTION - APPEND TO OVERLAY")

        #with open(self.input_path, 'rb') as infile:
        #    bytez = infile.read()
        
        #bytez = bytez + PefileManipulator.get_benign_content(random.randint(1, 100)).encode()
    
        #with open(self.output_path, 'wb') as outfile:
        #    outfile.write(bytez)
        
        os.system(f"cp -p {self.input_path} {self.output_path}")
        new_content = '\x00' + PefileManipulator.get_benign_content(random.randint(1, 100))

        with open(self.output_path, 'ab') as file:
            file.write(new_content.encode())

        return self.output_path

    def overlay_append_10(self):
        logger.info("ACTION - APPEND TO OVERLAY_10")
        
        os.system(f"cp -p {self.input_path} {self.output_path}")
        new_content = '\x00' + PefileManipulator.get_benign_content(10)

        with open(self.output_path, 'ab') as file:
            file.write(new_content.encode())

        return self.output_path
    
    def overlay_append_50(self):
        logger.info("ACTION - APPEND TO OVERLAY_50")
        
        os.system(f"cp -p {self.input_path} {self.output_path}")
        new_content = '\x00' + PefileManipulator.get_benign_content(50)

        with open(self.output_path, 'ab') as file:
            file.write(new_content.encode())

        return self.output_path

    def overlay_append_100(self):
        logger.info("ACTION - APPEND TO OVERLAY_100")
        
        os.system(f"cp -p {self.input_path} {self.output_path}")
        new_content = '\x00' + PefileManipulator.get_benign_content(100)

        with open(self.output_path, 'ab') as file:
            file.write(new_content.encode())

        return self.output_path        

    # TODO Improve 45/100
    # TODO probably won't work because of order of RVAs should be mantained
    # Shuffles section headers on byte level, doesn't show in pefile
    # TODO keep section alignment
    def shuffle_sections(self):
        logger.info("ACTION - SHUFFLE SECTION HEADERS")

        pe = PefileManipulator.load_PE(self.input_path)   
        
        
        OFFSET_OPTIONAL_HEADER = pe.OPTIONAL_HEADER.get_file_offset()
        SIZE_OPTIONAL_HEADER = pe.FILE_HEADER.SizeOfOptionalHeader
        NUM_SECTIONS = pe.FILE_HEADER.NumberOfSections
        OFFSET_SECTION_TABLE = OFFSET_OPTIONAL_HEADER + SIZE_OPTIONAL_HEADER
        ENTRY_SIZE = 40
        SECTION_HEADERS = [None] * NUM_SECTIONS
        
        
        bytez = pe.get_bytes_from_data(OFFSET_SECTION_TABLE, pe.get_data())
        
        # Extract individual section headers
        current_offset = 0
        for i in range(NUM_SECTIONS):
            SECTION_HEADERS[i] = bytez[current_offset:current_offset + ENTRY_SIZE]    
            current_offset += ENTRY_SIZE
    
        # shuffle
        random.shuffle(SECTION_HEADERS)
        reordered_section_table = b''.join(SECTION_HEADERS)

        # copy original file
        os.system(f"cp -p {self.input_path} {self.output_path}")
        
        # rewrite section table
        fh = open(self.output_path, "r+b")
        fh.seek(OFFSET_SECTION_TABLE)
        fh.write(reordered_section_table)
        fh.close()
        
        return self.output_path

        
    # 100/100 ok
    # Increase TimeDateStamp by 500 days
    def increase_timedatestamp(self):
        logger.info("ACTION - INCREASE TimeDateStamp")

        pe = PefileManipulator.load_PE(self.input_path) 
        
        pe.FILE_HEADER.TimeDateStamp = pe.FILE_HEADER.TimeDateStamp + 43200000  
        
        pe.write(self.output_path)
        
        return self.output_path
    
    # 100/100 ok
    # Decrease TimeDateStamp by 500 days    
    def decrease_timedatestamp(self):
        logger.info("ACTION - DECREASE TimeDateStamp")

        pe = PefileManipulator.load_PE(self.input_path) 
        
        pe.FILE_HEADER.TimeDateStamp = max(0, pe.FILE_HEADER.TimeDateStamp - 43200000)
        
        pe.write(self.output_path)
        
        return self.output_path
    

    
    def identity(self):
        logger.info("ACTION - IDENTITY")

        os.system(f"cp -p {self.input_path} {self.output_path}")
        
        return self.output_path
        

    # TODO improve 99/100
    # Append benign content to a section
    # Fill the available space after the section
    def append_section(self):
        logger.info("ACTION - APPEND TO SECTION")

        pe = PefileManipulator.load_PE(self.input_path)

        num_sections = len(pe.sections)

        candidate_sections = {}
        for i in range(num_sections):
            available_space_size = PefileManipulator.get_available_space_size(pe, i)

            if available_space_size > 0:
                candidate_sections[i] = available_space_size

        if len(candidate_sections) == 0:
            if self.verbose:
                logger.info("Cannot append to any of the sections, no space available.")

            os.system(f"cp -p {self.input_path} {self.output_path}")
            return self.output_path

        section_idx, available_size = random.choice(list(candidate_sections.items()))

        content = PefileManipulator.get_benign_content(random.randint(1, 100)).encode()

        while len(content) < available_size:
            content += PefileManipulator.get_benign_content(random.randint(1, 100)).encode()

        content = content[:available_size]

        section = pe.sections[section_idx]
        pe.set_bytes_at_offset(section.PointerToRawData + section.Misc_VirtualSize, content)

        pe.write(self.output_path)

        
        return self.output_path




    # TODO zero out old IDT
    # TODO Copy old ILT to a new section
    # TODO calculate correct new size of combined IDT and all respective ILTs and write to Data Directory
    # TODO IAT should be at the beginning of .code section
    # TODO IAT has a record in Data Directories, maybe copy the old IAT and create new one
    def append_imports(self):
        if self.verbose:     
            logger.info("ACTION - APPEND TO IMPORTS")

        pe = PefileManipulator.load_PE(self.input_path)   
        
        number_of_section = len(pe.sections)
        file_alignment = pe.OPTIONAL_HEADER.FileAlignment
        section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
        SECTION_ENTRY_SIZE = 40
        original_size = os.path.getsize(self.input_path)

            
        new_section_offset = pe.sections[-1].get_file_offset() + SECTION_ENTRY_SIZE # End of the last section header
        first_section_offset = pe.sections[0].PointerToRawData # Start of first section content
        next_header_space_size = first_section_offset - new_section_offset # Difference between start of first section and end of last section header
        
        # Not enough space for new section header
        if next_header_space_size < SECTION_ENTRY_SIZE:
            if self.verbose:
                logger.info("Cannot add new .idata section, not enough space for new section header.")
            os.system(f"cp -p {self.input_path} {self.output_path}")
            return self.output_path

        raw_offset = self.align((pe.sections[-1].PointerToRawData +
                        pe.sections[-1].SizeOfRawData),
                       file_alignment) # Offset of the new section's beginning (on disk)
        virtual_offset = self.align((pe.sections[-1].VirtualAddress +
                            pe.sections[-1].Misc_VirtualSize),
                           section_alignment) # Offset of the new section's beginning (in memory)

        # TODO prepare .idata content        
        # TODO IAT should be stored at the beginning of .text section (need to move all content further?, entry point etc.)
        DLL_name = random.choice(list(COMMON_IMPORTS.keys()))
        function_names = random.sample(COMMON_IMPORTS[DLL_name], min(random.randint(1, 25), len(COMMON_IMPORTS[DLL_name])))
        
        # Null-terminated strings
        DLL_name += '\x00'
        function_names = [func_name + '\x00' for func_name in function_names]

        content = bytes()
        NAME_content = bytes()


        IMPORT_ENTRY_SIZE = 20 # Size of import directory table entry
        #num_imported_dlls = 0

        old_IDT = bytes()


        # Copy old import directory table
        for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            if d.name == 'IMAGE_DIRECTORY_ENTRY_IMPORT':
                if d.Size > 0:
                    #num_imported_dlls = d.Size / IMPORT_ENTRY_SIZE
                    raw_IDT_offset = pe.get_physical_by_rva(d.VirtualAddress)
                    old_IDT_data = pe.__data__[raw_IDT_offset:raw_IDT_offset + d.Size]

                    while not PefileManipulator.all_zeros(old_IDT_data[0:IMPORT_ENTRY_SIZE]):
                        old_IDT += old_IDT_data[0:IMPORT_ENTRY_SIZE]
                        old_IDT_data = old_IDT_data[IMPORT_ENTRY_SIZE:]


                    # TODO 
                    #d.Size = d.Size + IMPORT_ENTRY_SIZE
                IDT_size = len(old_IDT) + 2*IMPORT_ENTRY_SIZE
                break


        ILT_ENTRY_SIZE = 4 # Import lookup/address table entry size
        if pe.OPTIONAL_HEADER.Magic == 0x10b: #PE32
            ILT_ENTRY_SIZE = 4
        elif pe.OPTIONAL_HEADER.Magic == 0x20b: #PE32+
            ILT_ENTRY_SIZE = 8

        
        ILT_RVA = virtual_offset + IDT_size
        ILT_size = ILT_ENTRY_SIZE*len(function_names) + ILT_ENTRY_SIZE
        #ILT_raw_offset = raw_offset + IDT_size

        IAT_RVA = ILT_RVA + 0
        IAT_size = ILT_size

        # Hint/Name table
        hint_name_RVA = IAT_RVA + IAT_size

        # New ILT entries
        ILT_table_content = bytes()
        func_name_RVA = hint_name_RVA   
            
        # Write ILT entry
        for func_name in function_names:  
            hint = '\x00\x00'
            padding = func_name_RVA % 2# Start at even byte
            func_name_RVA += padding
            NAME_content += (padding*'\x00').encode()
            NAME_content += (hint + func_name).encode()
            
            ILT_entry = bytearray(ILT_ENTRY_SIZE)
            ILT_entry[0:4] = struct.pack('<L', func_name_RVA)
            ILT_table_content += ILT_entry

            # Next name's RVA
            func_name_RVA += len(func_name) + len(hint)

        ILT_table_content += (ILT_ENTRY_SIZE*'\x00').encode() # Last empty entry
        assert len(ILT_table_content) == ILT_size

        # Write DLL name
        padding = func_name_RVA % 2 
        DLL_name_RVA = func_name_RVA + padding
        NAME_content += (padding*'\x00').encode() + (DLL_name + '\x00\x00').encode()

        # New IDT entry
        IDT_entry = bytearray(IMPORT_ENTRY_SIZE)
        IDT_entry[0:4] = struct.pack('<L', ILT_RVA) # RVA of import lookup table
        IDT_entry[4:8] = 4*b'\x00' #TimeDateStamp
        IDT_entry[8:12] = 4*b'\x00' #Forwarder Chain
        IDT_entry[12:16] = struct.pack('<L', DLL_name_RVA) # RVA of DLL name 
        IDT_entry[16:20] = struct.pack('<L', 0) #struct.pack('<L', ILT_RVA + ILT_size) # RVA of import address table


        # Write edited IDT to new section
        new_IDT = old_IDT + IDT_entry + (IMPORT_ENTRY_SIZE*'\x00').encode()
        assert len(new_IDT) == IDT_size
        content += new_IDT

        # ILT table
        content += ILT_table_content

        # IAT table
        #new_IAT_table = old_IAT[:-ILT_ENTRY_SIZE] + ILT_table_content
        #assert len(new_IAT_table) == IAT_size
        #content += new_IAT_table


        IDATA_content = content + NAME_content


        # Look for valid values for the new section header
        raw_size = self.align(len(IDATA_content), file_alignment) # align raw content size with FileAlignment (on disk)
        virtual_size = self.align(len(IDATA_content), section_alignment) # align raw content size with SectionAlignment (in memory)
        


        # Make space for new section content
        os.system(f"cp -p {self.input_path} {self.output_path}")
        fd = open(self.output_path, 'a+b')
        map = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_WRITE)
        map.resize(original_size + raw_size)
        map.close()
        fd.close()


        # Reload modified file
        pe = PefileManipulator.load_PE(self.output_path)   
        # Get name for the new section
        name = b'.idata\x00\x00'


        # READ | Initialized data
        characteristics = 0x40000000 | 0x40
       
        # Create the SEACTION HEADER
        # Set the Name
        pe.set_bytes_at_offset(new_section_offset, name)
        # Set the VirtualSize
        pe.set_dword_at_offset(new_section_offset + 8, virtual_size)
        # Set the VirtualAddress
        pe.set_dword_at_offset(new_section_offset + 12, virtual_offset)
        # Set the SizeOfRawData
        pe.set_dword_at_offset(new_section_offset + 16, raw_size)
        # Set the PointerToRawData
        pe.set_dword_at_offset(new_section_offset + 20, raw_offset)
        # Set the following fields to zero, not used in PE executable
        pe.set_bytes_at_offset(new_section_offset + 24, (12 * '\x00').encode())
        # Set the Characteristics
        pe.set_dword_at_offset(new_section_offset + 36, characteristics)

        # Modify the main headers
        pe.FILE_HEADER.NumberOfSections += 1
        pe.OPTIONAL_HEADER.SizeOfImage = virtual_size + virtual_offset

        # Overlay data
        old_overlay_offset = pe.get_overlay_data_start_offset()
        new_overlay_offset = raw_offset + raw_size
        overlay_content = pe.get_overlay()

        # Write main section content
        pe.set_bytes_at_offset(raw_offset, IDATA_content)
        
        # Move overlay further
        pe.set_bytes_at_offset(new_overlay_offset, bytes(overlay_content))

        # Redirect data directories
        for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            if d.name == 'IMAGE_DIRECTORY_ENTRY_SECURITY':
                if d.Size > 0:
                    d.VirtualAddress += new_overlay_offset - old_overlay_offset       
            elif d.name == 'IMAGE_DIRECTORY_ENTRY_IMPORT':
                    d.Size = IDT_size
                    d.VirtualAddress = virtual_offset

        pe.write(self.output_path)
        
        return self.output_path

        
        


ACTION_TABLE = {
    'rename_section': 'rename_section',
    'add_section': 'add_section',
    'append_section': 'append_section',
    'remove_certificate': 'remove_certificate',
    'remove_debug': 'remove_debug',
    'break_checksum': 'break_checksum',
    'overlay_append': 'overlay_append',
#    'overlay_append_10': 'overlay_append_10',
#    'overlay_append_50': 'overlay_append_50',
#    'overlay_append_100': 'overlay_append_100',

    #'shuffle_sections': 'shuffle_sections',
    'increase_timedatestamp': 'increase_timedatestamp',
    'decrease_timedatestamp': 'decrease_timedatestamp',
    'append_imports': 'append_imports',

    #'identity': 'identity'
}



# Takes file provided by 'input_path',
# modifies it by given 'actions', result file is saved to 'output_folder'
def modify_PE_file(input_path, output_folder = tempfile._get_default_tempdir(), actions=[], verbose=False, rename_result_file=True):
    current_path = input_path
    output_path = PefileManipulator.get_output_path(output_folder, input_path, rename_result_file)   
    failure = False

    for action in actions:
        #if action == None:
        #    os.system(f"cp -p {current_path} {output_path}")
        #    current_path = output_path
        #    continue
            
        _action = ACTION_TABLE[action]

        try:
            current_path = PefileManipulator(current_path, output_folder, verbose, rename_result_file).__getattribute__(_action)()
        except Exception as e:
            logger.exception(f"Error during performing action: {action}, {e}")
            os.system(f"cp -p {current_path} {output_path}")    
            current_path = output_path
            failure = True


    return failure, current_path



       



# TODO IMPROVE 39/100
    #rework with pefile
    """
    def append_imports(self):     
        logger.info("ACTION - APPEND TO IMPORTS")
  
        #pe = PefileManipulator.load_PE(self.input_path)    
        #e_lfanew = pe.DOS_HEADER.e_lfanew
        
        with open(self.input_path, 'rb') as infile:
            bytez = infile.read()      
            
        #old_DOS = bytez[:e_lfanew]     
               
        importsFile = open(imported_libs , 'w') # Creates new file
        
        libname = random.choice(list(COMMON_IMPORTS))

        #while(len(list(COMMON_IMPORTS[libname])) < 20 ):
        #    libname = random.choice(list(COMMON_IMPORTS))

        # Save imported functions and lib name to it 
        importsFile.write(libname + '\n')
        for fun in (list(COMMON_IMPORTS[libname])):
            importsFile.write(fun + '\n')

        importsFile.close()

        tmp_path = self.output_path #self.get_output_path(tempfile._get_default_tempdir(), self.input_path)
        
        
        with open(tmp_path, 'wb') as file1:
            file1.write(bytez)

        cmd = f"{append_import_script} {tmp_path} {imported_libs} {self.output_path}"
        os.system(cmd)

        #with open(tmp_path, "rb") as binfile:
        #    bytez = binfile.read()
            
        #correct_file = old_DOS + bytez[16:]
        
        #with open(self.output_path, 'wb') as res_file:
        #    res_file.write(correct_file)
            

        return self.output_path
    """

    # TODO Not working
    # Physical size seems off
    def not_working_add_section(self):   
        if self.verbose:     
            logger.info("ACTION - ADD SECTION")

        pe = PefileManipulator.load_PE(self.input_path)   
        
        last_section = pe.sections[-1]
        ENTRY_SIZE = 40
        original_size = os.path.getsize(self.input_path)


        
        new_section_offset = last_section.get_file_offset() + ENTRY_SIZE # End of last section header
        first_section_offset = pe.OPTIONAL_HEADER.SizeOfHeaders # Start of first section data
        next_header_space_size = first_section_offset - new_section_offset # Difference between start of first section and end of last section header
        
        # Not enough space for new section header
        if next_header_space_size < ENTRY_SIZE:
            if self.verbose:
                logger.info("Cannot add new section, not enough space for new section header.")
            os.system(f"cp -p {self.input_path} {self.output_path}")
            return self.output_path

        content = PefileManipulator.get_benign_content(random.randint(1, 100))
        content_length = len(content)
        new_section_data = bytearray(self.align(content_length, pe.OPTIONAL_HEADER.FileAlignment))
        new_section_data[:content_length] = content.encode()
        data_length = len(new_section_data)

        # Make space for new section content
        os.system(f"cp -p {self.input_path} {self.output_path}")
        fd = open(self.output_path, 'a+b')
        map = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_WRITE)
        map.resize(original_size + data_length)
        map.close()
        fd.close()


        # Reload modified file
        pe = PefileManipulator.load_PE(self.output_path)   

        new_section = pefile.SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)

        # fill with zeros
        new_section.__unpack__(bytearray(new_section.sizeof()))


        new_section.set_file_offset(last_section.get_file_offset() + last_section.sizeof())

        new_section.Name = "".join(PefileManipulator.get_random_section_name()).encode()
        
        #print(hex(pe.OPTIONAL_HEADER.FileAlignment))
        #print(hex(content_length), hex(self.align(content_length, pe.OPTIONAL_HEADER.FileAlignment)))

        new_section.SizeOfRawData = data_length #self.align(content_length, pe.OPTIONAL_HEADER.FileAlignment)
        new_section.PointerToRawData = self.align(last_section.PointerToRawData + last_section.SizeOfRawData, pe.OPTIONAL_HEADER.FileAlignment) #len(pe.__data__)

        new_section.Misc_PhysicalAddress = data_length
        new_section.Misc_VirtualSize = self.align(content_length, pe.OPTIONAL_HEADER.SectionAlignment)
        new_section.VirtualAddress = last_section.VirtualAddress + self.align(last_section.Misc_VirtualSize, pe.OPTIONAL_HEADER.SectionAlignment)

        new_section.Characteristics = PefileManipulator.get_benign_section_characteristics()


        # increase size of image
        pe.OPTIONAL_HEADER.SizeOfImage += self.align(data_length, pe.OPTIONAL_HEADER.SectionAlignment)

        # increase number of sections
        pe.FILE_HEADER.NumberOfSections += 1

        # append new section to structures
        pe.sections.append(new_section)
        pe.__structures__.append(new_section)

        # add new section data to file
        pe.__data__ = bytearray(pe.__data__) + new_section_data

        pe.write(self.output_path)
        return self.output_path
